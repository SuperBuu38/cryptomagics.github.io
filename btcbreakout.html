<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC/USD Interactive Chart</title>
    <style>
        body { margin: 0; font-family: Arial, sans-serif; background-color: #1e222d; }
        #chart-container { 
            width: 100%; 
            height: 600px; 
            visibility: hidden;
        }
        #volume-container {
            width: 100%;
            height: 150px;
            visibility: hidden;
        }
        #controls { 
            margin-top: 10px; 
            text-align: center;
            padding: 10px;
            background-color: #2a2e39;
        }
        button {
            margin: 5px;
            padding: 8px 15px;
            background-color: #2962ff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover { background-color: #1e4bd8; }
        #status {
            color: #d1d4dc;
            margin-top: 10px;
            text-align: center;
        }
        #indicators {
            color: #d1d4dc;
            margin-top: 10px;
            text-align: center;
        }
        #loading {
            color: white;
            text-align: center;
            padding: 20px;
        }
    </style>
</head>
<body>
    <div id="loading">Chargement du graphique...</div>
    <div id="chart-container"></div>
    <div id="volume-container"></div>
    <div id="controls">
        <button id="detect-support-resistance">D√©tecter Supports & R√©sistances</button>
        <button id="toggle-breakout-detection">Activer D√©tection Breakout</button>
        <button id="clear-lines">Effacer les lignes</button>
    </div>
    <div id="status"></div>
    <div id="indicators"></div>

    <script>
        function loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        async function initChart() {
            try {
                await loadScript('https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js');
                
                if (typeof LightweightCharts === 'undefined') {
                    throw new Error('La librairie LightweightCharts n\'a pas pu √™tre charg√©e');
                }

                document.getElementById('loading').style.display = 'none';
                document.getElementById('chart-container').style.visibility = 'visible';
                document.getElementById('volume-container').style.visibility = 'visible';

                // Configuration principale du graphique
                const chart = LightweightCharts.createChart(document.getElementById('chart-container'), {
                    layout: {
                        background: { color: '#1e222d' },
                        textColor: '#d1d4dc',
                    },
                    grid: {
                        vertLines: { color: '#2a2e39' },
                        horzLines: { color: '#2a2e39' }
                    },
                    crosshair: {
                        mode: LightweightCharts.CrosshairMode.Normal,
                        vertLine: {
                            width: 1,
                            color: '#2962FF',
                            style: LightweightCharts.LineStyle.Solid,
                        },
                        horzLine: {
                            width: 1,
                            color: '#2962FF',
                            style: LightweightCharts.LineStyle.Solid,
                        },
                    },
                    rightPriceScale: {
                        borderColor: '#2a2e39',
                        scaleMargins: {
                            top: 0.1,
                            bottom: 0.1,
                        },
                    },
                    timeScale: {
                        borderColor: '#2a2e39',
                        timeVisible: true,
                        secondsVisible: false
                    },
                });

                // Graphique du volume
                const volumeChart = LightweightCharts.createChart(document.getElementById('volume-container'), {
                    height: 150,
                    layout: {
                        background: { color: '#1e222d' },
                        textColor: '#d1d4dc',
                    },
                    grid: {
                        vertLines: { color: '#2a2e39' },
                        horzLines: { color: '#2a2e39' }
                    },
                    rightPriceScale: {
                        borderColor: '#2a2e39',
                        scaleMargins: {
                            top: 0.1,
                            bottom: 0.1,
                        },
                    },
                    timeScale: {
                        borderColor: '#2a2e39',
                        visible: false,
                    },
                });

                function resizeCharts() {
                    const width = document.body.clientWidth;
                    chart.applyOptions({ width: width, height: 600 });
                    volumeChart.applyOptions({ width: width, height: 150 });
                }
                window.addEventListener('resize', resizeCharts);
                resizeCharts();

                // S√©ries de donn√©es
                const candleSeries = chart.addCandlestickSeries({
                    upColor: '#26a69a',
                    downColor: '#ef5350',
                    borderVisible: false,
                    wickUpColor: '#26a69a',
                    wickDownColor: '#ef5350'
                });

                const volumeSeries = volumeChart.addHistogramSeries({
                    color: '#385263',
                    priceFormat: {
                        type: 'volume',
                    },
                    priceScaleId: '',
                });

                // Indicateurs techniques
                const rsiSeries = chart.addLineSeries({
                    color: 'rgba(255, 192, 0, 1)',
                    lineWidth: 1,
                    priceLineVisible: false,
                    lastValueVisible: false,
                });

                const macdSeries = chart.addLineSeries({
                    color: 'rgba(41, 98, 255, 1)',
                    lineWidth: 1,
                    priceLineVisible: false,
                    lastValueVisible: false,
                });

                let currentData = [];
                let priceLines = [];
                let breakoutDetectionEnabled = false;
                let confirmedBreakouts = new Set();

                // Fonctions utilitaires
                function calculateRSI(data, periods = 14) {
                    let gains = [];
                    let losses = [];
                    
                    for (let i = 1; i < data.length; i++) {
                        const difference = data[i].close - data[i - 1].close;
                        gains.push(Math.max(0, difference));
                        losses.push(Math.max(0, -difference));
                    }
                    
                    const averageGain = gains.slice(0, periods).reduce((a, b) => a + b, 0) / periods;
                    const averageLoss = losses.slice(0, periods).reduce((a, b) => a + b, 0) / periods;
                    
                    let rs = averageGain / averageLoss;
                    let rsi = 100 - (100 / (1 + rs));
                    
                    return { time: data[periods].time, value: rsi };
                }

                function calculateMACD(data, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
                    const closes = data.map(d => d.close);
                    const fastEMA = calculateEMA(closes, fastPeriod);
                    const slowEMA = calculateEMA(closes, slowPeriod);
                    const macd = fastEMA - slowEMA;
                    
                    return { time: data[data.length - 1].time, value: macd };
                }

                function calculateEMA(data, periods) {
                    const k = 2 / (periods + 1);
                    let ema = data[0];
                    
                    for (let i = 1; i < data.length; i++) {
                        ema = data[i] * k + ema * (1 - k);
                    }
                    
                    return ema;
                }

                function updateStatus(message) {
                    document.getElementById('status').textContent = message;
                }

                function clearPriceLines() {
                    priceLines.forEach(line => candleSeries.removePriceLine(line));
                    priceLines = [];
                    confirmedBreakouts.clear();
                }

                // D√©tection des niveaux de support et r√©sistance
                function detectSupportResistance(data) {
                    clearPriceLines();
                    
                    const pivotPoints = [];
                    const strength = 5;
                    const minDistance = 100;
                    const volumeThreshold = calculateAverageVolume(data) * 1.5;

                    for (let i = strength; i < data.length - strength; i++) {
                        let isSupport = true;
                        let isResistance = true;

                        for (let j = i - strength; j < i + strength; j++) {
                            if (j === i) continue;
                            
                            if (data[i].low > data[j].low) isSupport = false;
                            if (data[i].high < data[j].high) isResistance = false;
                            
                            if (!isSupport && !isResistance) break;
                        }

                        if ((isSupport || isResistance) && data[i].volume > volumeThreshold) {
                            pivotPoints.push({
                                price: isSupport ? data[i].low : data[i].high,
                                type: isSupport ? 'support' : 'resistance',
                                time: data[i].time,
                                strength: 0,
                                volume: data[i].volume
                            });
                        }
                    }

                    // Calcul de la force des niveaux
                    pivotPoints.forEach(point => {
                        let touches = 0;
                        let volumeScore = 0;
                        
                        data.forEach(candle => {
                            if (Math.abs(candle.high - point.price) < minDistance / 10 ||
                                Math.abs(candle.low - point.price) < minDistance / 10) {
                                touches++;
                                volumeScore += candle.volume;
                            }
                        });
                        
                        point.strength = touches * (volumeScore / (touches || 1));
                    });

                    // Filtrage et cr√©ation des zones
                    const significantLevels = pivotPoints
                        .sort((a, b) => b.strength - a.strength)
                        .filter((point, index) => {
                            if (index === 0) return true;
                            return !pivotPoints
                                .slice(0, index)
                                .some(p => Math.abs(p.price - point.price) < minDistance);
                        })
                        .slice(0, 8);

                    significantLevels.forEach(level => {
                        // Cr√©ation de la zone au lieu d'une simple ligne
                        const zoneWidth = level.price * 0.002; // Zone de 0.2%
                        
                        const upperLine = candleSeries.createPriceLine({
                            price: level.price + zoneWidth/2,
                            color: level.type === 'support' ? '#26a69a' : '#ef5350',
                            lineWidth: 1,
                            lineStyle: LightweightCharts.LineStyle.Dotted,
                        });
                        
                        const mainLine = candleSeries.createPriceLine({
                            price: level.price,
                            color: level.type === 'support' ? '#26a69a' : '#ef5350',
                            lineWidth: 2,
                            lineStyle: LightweightCharts.LineStyle.Solid,
                            axisLabelVisible: true,
                            title: `${level.type === 'support' ? 'S' : 'R'} (${Math.round(level.strength)})`,
                        });
                        
                        const lowerLine = candleSeries.createPriceLine({
                            price: level.price - zoneWidth/2,
                            color: level.type === 'support' ? '#26a69a' : '#ef5350',
                            lineWidth: 1,
                            lineStyle: LightweightCharts.LineStyle.Dotted,
                        });
                        
                        priceLines.push(upperLine, mainLine, lowerLine);
                    });

                    updateStatus(`D√©tect√© ${significantLevels.length} niveaux significatifs`);
                }

                function calculateAverageVolume(data) {
                    return data.reduce((sum, candle) => sum + candle.volume, 0) / data.length;
                }

                // D√©tection des breakouts
                function detectBreakout(candle) {
                    if (!breakoutDetectionEnabled || priceLines.length === 0) return;

                    const averageVolume = calculateAverageVolume(currentData.slice(-20));
                    const volumeIncrease = candle.volume > averageVolume * 1.5;
                    
                    priceLines.forEach(line => {
                        if (line.options().lineStyle !== LightweightCharts.LineStyle.Solid) return;
                        
                        const level = line.options().price;
                        const previousCandles = currentData.slice(-4);
                        const breakoutKey = `${level}-${candle.time}`;

                        if (confirmedBreakouts.has(breakoutKey)) return;

                        // D√©tection de breakout haussier
                        if (previousCandles.every(c => c.close <= level) && 
                            candle.close > level && 
                            volumeIncrease) {
                            
                            let confirmed = true;
                            for (let i = 1; i <= 3; i++) {
                                if (currentData[currentData.length - i]?.close <= level) {
                                    confirmed = false;
                                    break;
                                }
                            }

                            if (confirmed) {
                                confirmedBreakouts.add(breakoutKey);
                                updateStatus(`üöÄ Breakout haussier confirm√© √† ${level.toFixed(2)} avec volume important`);
                            }
                        }
                        // D√©tection de breakout baissier
                        else if (previousCandles.every(c => c.close >= level) && 
                                candle.close < level && 
                                volumeIncrease) {
                            
                            let confirmed = true;
                            for (let i = 1; i <= 3; i++) {
if (currentData[currentData.length - i]?.close >= level) {
                                    confirmed = false;
                                    break;
                                }
                            }

                            if (confirmed) {
                                confirmedBreakouts.add(breakoutKey);
                                updateStatus(`üìâ Breakout baissier confirm√© √† ${level.toFixed(2)} avec volume important`);
                            }
                        }

                        // D√©tection des faux breakouts
                        const recentBreakouts = Array.from(confirmedBreakouts)
                            .filter(key => key.startsWith(level.toString()));

                        recentBreakouts.forEach(breakoutKey => {
                            const [breakoutLevel, breakoutTime] = breakoutKey.split('-');
                            const level = parseFloat(breakoutLevel);
                            
                            // V√©rifier si le prix est revenu dans la zone
                            if ((candle.close < level && previousCandles[0].close > level) ||
                                (candle.close > level && previousCandles[0].close < level)) {
                                confirmedBreakouts.delete(breakoutKey);
                                updateStatus(`‚ö†Ô∏è Faux breakout d√©tect√© √† ${level.toFixed(2)}`);
                            }
                        });
                    });
                }

                // Calcul de la probabilit√© de rebond
                function calculateBounceProximity(price, levels) {
                    const proximityScores = levels.map(level => {
                        const distance = Math.abs(price - level.price);
                        const maxDistance = level.price * 0.01; // 1% de la valeur du niveau
                        return {
                            level: level.price,
                            type: level.type,
                            probability: Math.max(0, 100 * (1 - distance / maxDistance)),
                            strength: level.strength
                        };
                    });

                    return proximityScores
        .filter(score => score.probability > 0)
        .sort((a, b) => b.probability - a.probability);
                }

                // Mise √† jour des indicateurs techniques
                function updateIndicators(data) {
                    if (data.length < 26) return; // Minimum requis pour MACD

                    const rsi = calculateRSI(data);
                    const macd = calculateMACD(data);

                    rsiSeries.update(rsi);
                    macdSeries.update(macd);

                    const lastCandle = data[data.length - 1];
                    const bounceProbs = calculateBounceProximity(
                        lastCandle.close,
                        priceLines
                            .filter(line => line.options().lineStyle === LightweightCharts.LineStyle.Solid)
                            .map(line => ({
                                price: line.options().price,
                                type: line.options().title.startsWith('S') ? 'support' : 'resistance',
                                strength: parseInt(line.options().title.match(/\((\d+)\)/)[1])
                            }))
                    );

                    document.getElementById('indicators').innerHTML = `
                        RSI: ${rsi.value.toFixed(2)} | 
                        MACD: ${macd.value.toFixed(2)} | 
                        ${bounceProbs.length > 0 ? 
                            `Probabilit√© de rebond: ${bounceProbs[0].type} √† ${bounceProbs[0].level.toFixed(2)} (${bounceProbs[0].probability.toFixed(1)}%)` : 
                            'Pas de niveau proche'}
                    `;
                }

                // Event Listeners
                document.getElementById('detect-support-resistance').addEventListener('click', () => {
                    if (currentData.length > 0) {
                        detectSupportResistance(currentData);
                    }
                });

                document.getElementById('toggle-breakout-detection').addEventListener('click', (e) => {
                    breakoutDetectionEnabled = !breakoutDetectionEnabled;
                    e.target.textContent = breakoutDetectionEnabled ? 'D√©sactiver D√©tection Breakout' : 'Activer D√©tection Breakout';
                    updateStatus(breakoutDetectionEnabled ? 'D√©tection des breakouts activ√©e' : 'D√©tection des breakouts d√©sactiv√©e');
                });

                document.getElementById('clear-lines').addEventListener('click', () => {
                    clearPriceLines();
                    updateStatus('Lignes effac√©es');
                });

                // Chargement des donn√©es historiques
                try {
                    const response = await fetch('https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=5m&limit=1500');
                    const data = await response.json();
                    
                    currentData = data.map(item => ({
                        time: item[0] / 1000,
                        open: parseFloat(item[1]),
                        high: parseFloat(item[2]),
                        low: parseFloat(item[3]),
                        close: parseFloat(item[4]),
                        volume: parseFloat(item[5])
                    }));
                    
                    candleSeries.setData(currentData);
                    volumeSeries.setData(
                        currentData.map(item => ({
                            time: item.time,
                            value: item.volume,
                            color: item.close >= item.open ? '#26a69a' : '#ef5350'
                        }))
                    );
                    
                    updateIndicators(currentData);
                    updateStatus('Donn√©es historiques charg√©es');
                } catch (err) {
                    updateStatus('Erreur lors du chargement des donn√©es: ' + err.message);
                }

                // WebSocket pour les donn√©es en temps r√©el
                const binanceSocket = new WebSocket('wss://stream.binance.com:9443/ws/btcusdt@kline_5m');
                binanceSocket.onmessage = function(event) {
                    const message = JSON.parse(event.data);
                    const candlestick = {
                        time: message.k.t / 1000,
                        open: parseFloat(message.k.o),
                        high: parseFloat(message.k.h),
                        low: parseFloat(message.k.l),
                        close: parseFloat(message.k.c),
                        volume: parseFloat(message.k.v)
                    };

                    if (message.k.x) { // bougie compl√©t√©e
                        currentData.push(candlestick);
                        if (currentData.length > 1500) currentData.shift();
                        detectBreakout(candlestick);
                        updateIndicators(currentData);
                    }
                    
                    candleSeries.update(candlestick);
                    volumeSeries.update({
                        time: candlestick.time,
                        value: candlestick.volume,
                        color: candlestick.close >= candlestick.open ? '#26a69a' : '#ef5350'
                    });
                };

                binanceSocket.onopen = () => updateStatus('Connect√© au flux en temps r√©el');
                binanceSocket.onerror = (error) => updateStatus('Erreur WebSocket: ' + error.message);
                binanceSocket.onclose = () => updateStatus('Connexion WebSocket ferm√©e');

            } catch (error) {
                document.getElementById('loading').textContent = 'Erreur lors du chargement: ' + error.message;
                console.error('Erreur d\'initialisation:', error);
            }
        }

        // D√©marrer l'initialisation
        initChart();
    </script>
</body>
</html>